class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.size() == 0 || nums.size() == 1)
        {
            return nums.size();
        }

        unordered_set<int> tmp;
        int max = 0;

        //记录所有元素到哈希表
        for (int i = 0; i < nums.size(); ++i)
        {
            tmp.insert(nums[i]);
        }

        //再遍历一次，寻找最大长度
        for (int i = 0; i < nums.size(); ++i)
        {
            //如果这个数不在哈希表中，说明已经被处理过了，跳过
            if (tmp.end() == tmp.find(nums[i]))
            {
                continue;
            }

            //找到一个没被处理过的数，以它为中点，往前寻找最长序列，往后寻找最长序列，把前后两个值相加
            //每找到一个数，就把它从哈希表中删掉，避免重复处理
            int middle = nums[i], left_len = 0, right_len = 0;

            //往前寻找
            int current = middle - 1;
            while (true)
            {
                if (tmp.end() != tmp.find(current)) //有这个数，递增序列长度，并把它从哈希表删除
                {
                    ++left_len;
                    tmp.erase(current);
                    --current;
                }
                else    //找不到了，跳出
                {
                    break;
                }
            }

            //往后寻找，同理
            current = middle + 1;
            while (true)
            {
                if (tmp.end() != tmp.find(current))
                {
                    ++right_len;
                    tmp.erase(current);
                    ++current;
                }
                else
                {
                    break;
                }
            }

            //计算序列长度
            int len = left_len + right_len + 1;
            if (len > max)
            {
                max = len;
            }

            tmp.erase(middle);
        }

        return max;
    }
};
